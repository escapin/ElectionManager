var forge = require('node-forge');

// All the input (arguments) and output (returned values) of
// functions defined in this module are (assumed to be)
// hex-encoded.

//////////////////////////////////////////////////////////////////////////
// SHORTCUTS

var rsa = forge.pki.rsa;
var pki = forge.pki;

var hexToBytes = forge.util.hexToBytes;
var bytesToHex = forge.util.bytesToHex;

//////////////////////////////////////////////////////////////////////////
// UTILS


function int32ToHexString(integer) {
    var b = forge.util.createBuffer();
    b.putInt32(integer);
    return b.toHex()
}

function hexStringToInt(hexstring) {
    return parseInt(hexstring, 16);
}


// Concatenation and deconcatenate messages
// (as allways, artuments are hex encododed)
function concatenate(a, b) {
    var a_length =  int32ToHexString(a.length/2);
    return a_length + a + b;
}

function deconcatenate(message) {
    var splitpos = 2*hexStringToInt(message.slice(null, 8));
    var a = message.slice(8, splitpos+8);
    var b = message.slice(splitpos+8);
    return {first:a, second:b};
}

exports.concatenate = concatenate;
exports.deconcatenate = deconcatenate;


//////////////////////////////////////////////////////////////////////////
// DIGESTS

// Returns SHA1-digest (160 bits) of message
//
exports.hash = function hash(message) {
    var md = forge.md.sha1.create()
    md.update(message, 'utf8');
    return md.digest().toHex();
}


//////////////////////////////////////////////////////////////////////////
// RANDOM

// Returns a 160-bit random value (hex-encoded)
//
exports.nonce = function nonce() {
    return bytesToHex(forge.random.getBytesSync(20));
}


//////////////////////////////////////////////////////////////////////////
// SYMMETRIC KEY AUTHENTICATED ENCRYPTION

// Public key encryption 
// (AES in GCM mode with 96-bit random IV)
//
function symenc(key, message) {
    key = hexToBytes(key);
    message = hexToBytes(message);

    var iv = forge.random.getBytesSync(12); // take a random iv
    var cipher = forge.cipher.createCipher('AES-GCM', key);
    cipher.start({
      iv: iv, // should be a 12-byte binary-encoded string or byte buffer
      tagLength: 128 // optional, defaults to 128 bits
    });
    cipher.update(forge.util.createBuffer(message));
    cipher.finish();
    var enc = cipher.output;
    var tag = cipher.mode.tag; // authentication tag

    // the result ciphertext =  iv | enc | tag
    var c = forge.util.createBuffer();
    c.putBytes(iv);
    c.putBytes(enc.data);
    c.putBytes(tag.data);
    return c.toHex();
}


// Decryption
// (AES in GCM mode with 96-bit random IV)
//
function symdec(key, ciphertext) {
    key = hexToBytes(key);
    ciphertext = forge.util.createBuffer(hexToBytes(ciphertext));

    // split the ciphertext into iv, enc, and tag:
    var iv =  ciphertext.getBytes(12);
    var enc = ciphertext.getBytes(ciphertext.length() - 16);
    var tag = ciphertext.getBytes();

    var decipher = forge.cipher.createDecipher('AES-GCM', key);
    decipher.start({
      iv: iv,
      tagLength: 128, // optional, defaults to 128 bits
      tag: tag // authentication tag from encryption
    });
    decipher.update(forge.util.createBuffer(enc));
    var pass = decipher.finish();
    if(pass) { // decryption succeeded
        return decipher.output.toHex();
    }
    else // decryption failure
        return null;
}

// Key generation for symmetric encryption.
// A key is simply a hex-formated random 32-byte string
//
function symkeygen() {
    return bytesToHex(forge.random.getBytesSync(32));
}

exports.symkeygen = symkeygen;
exports.symenc = symenc;
exports.symdec = symdec;

//////////////////////////////////////////////////////////////////////////
// PUBLIC KEY AUTHENTICATED ENCRYPTION 

// Private key encoding/decoding (to/from hex) - PKCS#8
//
function privateKeyToHex(privateKey) {
    return bytesToHex(forge.asn1.toDer(pki.privateKeyToAsn1(privateKey)).getBytes());
}
function hexToPrivateKey(hexPrivateKey) {
    return pki.privateKeyFromAsn1(forge.asn1.fromDer(hexToBytes(hexPrivateKey)));
}

exports.privateKeyToHex = privateKeyToHex;
exports.hexToPrivateKey = hexToPrivateKey;

// Public key encoding/decoding (to/from hex) - X.509
//
function publicKeyToHex(publicKey) {
    return bytesToHex(forge.asn1.toDer(pki.publicKeyToAsn1(publicKey)).getBytes());
}
function hexToPublicKey(hexPublicKey) {
    return pki.publicKeyFromAsn1(forge.asn1.fromDer(hexToBytes(hexPublicKey)));
}

exports.publicKeyToHex = publicKeyToHex;
exports.hexToPublicKey = hexToPublicKey;

// Generates RSA public key pair
function rsa_keygen(length) {
    if (!length) length = 1024;
    keypair = rsa.generateKeyPair({bits: length, e: 0x10001});
    return { encryptionKey : publicKeyToHex(keypair.publicKey),  
             decryptionKey : privateKeyToHex(keypair.privateKey) };
}

// Public key encryption.
// Uses RSAES PKCS#1 v1.5
function rsa_encrypt(publicKey, message) {
    var pk = hexToPublicKey(publicKey);
    return bytesToHex(pk.encrypt(hexToBytes(message)));
}

// Public key decryption.
// Uses RSAES PKCS#1 v1.5
//
function rsa_decrypt(privateKey, ciphertext) {
    var sk = hexToPrivateKey(privateKey);
    return bytesToHex(sk.decrypt(hexToBytes(ciphertext)));
}

exports.rsa_keygen = rsa_keygen;
exports.rsa_encrypt = rsa_encrypt;
exports.rsa_decrypt = rsa_decrypt;

//////////////////////////////////////////////////////////////////////////
// PUBLIC-KEY HYBRID ENCRYPTION


// Public-key hybrid key generation
//
exports.pke_keygen = exports.rsa_keygen;


// Public-key hybrid key encrytpion
//
exports.pke_encrypt = function pke_encrypt(encryptionKey, message) {
    var key = symkeygen();
    var encryptedKey = rsa_encrypt(encryptionKey, key);
    var encryptedMessage = symenc(key, message)
    return concatenate(encryptedKey, encryptedMessage);
}


// Public-key hybrid key decryption
//
exports.pke_decrypt = function pke_decrypt(decryptionKey, message) {
    var m = deconcatenate(message);
    var key = rsa_decrypt(decryptionKey, m.first);
    return symdec(key, m.second);
}


////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

