var forge = require('node-forge');

// All the input (arguments) and output (returned values) of
// functions defined in this module are (assumed to be)
// hex-encoded.

// SHORTCUTS

var rsa = forge.pki.rsa;
var pki = forge.pki;

var hexToBytes = forge.util.hexToBytes;
var bytesToHex = forge.util.bytesToHex;

// DIGESTS

// Returns SHA1-digest (160 bits) of message
//
exports.hash = function hash(message) {
    var md = forge.md.sha1.create()
    md.update(message, 'utf8');
    return md.digest().toHex();
}


// RANDOM

// Returns a 160-bit random value (hex-encoded)
//
exports.nonce = function nonce() {
    return bytesToHex(forge.random.getBytesSync(20));
}


// SYMMETRIC KEY AUTHENTICATED ENCRYPTION

// Public key encryption 
// (AES in GCM mode with 96-bit random IV)
//
exports.symenc = function symenc(key, message) {
    key = hexToBytes(key);
    message = hexToBytes(message);

    var iv = forge.random.getBytesSync(12); // take a random iv
    var cipher = forge.cipher.createCipher('AES-GCM', key);
    cipher.start({
      iv: iv, // should be a 12-byte binary-encoded string or byte buffer
      tagLength: 128 // optional, defaults to 128 bits
    });
    cipher.update(forge.util.createBuffer(message));
    cipher.finish();
    var enc = cipher.output;
    var tag = cipher.mode.tag; // authentication tag

    // the result ciphertext =  iv | enc | tag
    var c = forge.util.createBuffer();
    c.putBytes(iv);
    c.putBytes(enc.data);
    c.putBytes(tag.data);
    return c.toHex();
}


// Decryption
// (AES in GCM mode with 96-bit random IV)
//
exports.symdec = function symdec(key, ciphertext) {
    key = hexToBytes(key);
    ciphertext = forge.util.createBuffer(hexToBytes(ciphertext));

    // split the ciphertext into iv, enc, and tag:
    var iv =  ciphertext.getBytes(12);
    var enc = ciphertext.getBytes(ciphertext.length() - 16);
    var tag = ciphertext.getBytes();

    var decipher = forge.cipher.createDecipher('AES-GCM', key);
    decipher.start({
      iv: iv,
      tagLength: 128, // optional, defaults to 128 bits
      tag: tag // authentication tag from encryption
    });
    decipher.update(forge.util.createBuffer(enc));
    var pass = decipher.finish();
    if(pass) { // decryption succeeded
        return decipher.output.toHex();
    }
    else // decryption failure
        return null;
}

// Key generation for symmetric encryption.
// A key is simply a hex-formated random 32-byte string
//
exports.symkeygen = function symkeygen() {
    return bytesToHex(forge.random.getBytesSync(32));
}


// PUBLIC KEY AUTHENTICATED ENCRYPTION 

// Private key encoding/decoding (to/from hex) - PKCS#8
//
function privateKeyToHex(privateKey) {
    return bytesToHex(forge.asn1.toDer(pki.privateKeyToAsn1(privateKey)).getBytes());
}
function hexToPrivateKey(hexPrivateKey) {
    return pki.privateKeyFromAsn1(forge.asn1.fromDer(hexToBytes(hexPrivateKey)));
}

exports.privateKeyToHex = privateKeyToHex;

// Public key encoding/decoding (to/from hex) - X.509
//
function publicKeyToHex(publicKey) {
    return bytesToHex(forge.asn1.toDer(pki.publicKeyToAsn1(publicKey)).getBytes());
}
function hexToPublicKey(hexPublicKey) {
    return pki.publicKeyFromAsn1(forge.asn1.fromDer(hexToBytes(hexPublicKey)));
}

exports.publicKeyToHex = publicKeyToHex;

// Generates RSA public key pair
exports.rsa_keygen = function rsa_keygen(length) {
    if (!length) length = 1024;
    keypair = rsa.generateKeyPair({bits: length, e: 0x10001});
    return { encryptionKey : publicKeyToHex(keypair.publicKey),  
             decryptionKey : privateKeyToHex(keypair.privateKey) };
}

// Public key encryption.
// Uses RSAES PKCS#1 v1.5
exports.rsa_encrypt = function rsa_encrypt(publicKey, message) {
    var pk = hexToPublicKey(publicKey);
    return bytesToHex(pk.encrypt(hexToBytes(message)));
}

// Public key decryption.
// Uses RSAES PKCS#1 v1.5
//
exports.rsa_decrypt = function rsa_decrypt(privateKey, ciphertext) {
    var sk = hexToPrivateKey(privateKey);
    return bytesToHex(sk.decrypt(hexToBytes(ciphertext)));
}

