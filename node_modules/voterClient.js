var voterClient = function() {
var exports = {};
//////////////////////////////////////////////////////////////////////////////////////////////

var crypto = require('./cryptofunc');

// PARAMETERS

var TAG_ACCEPTED = "00"; // (hex encoded) tag 

// SHORTCUTS

var pair = crypto.concatenate;
var enc  = crypto.pke_encrypt;
var dec  = crypto.pke_decrypt;

// Returns a new voter client instance
exports.create = function(electionID, colServVerifKey, mixServEncKeys)
{
    ///
    // Method createBallot
    //
    // Returns
	//  	ENC_mix1(electionID, ENC_Mix2( electionID, ... Enc_MixN(electionID, choice, receiptID)...)
    //
    // Arguments:
    //   hexenc   	electionID
    //   hexenc[]	mixServEncKeys
    //   int      	choice
    //
    // Returns:
    //   a receipt
    //
    function createBallot (choice) {
        // TODO choice now is an integer. It coule be an arbitrary message
        var choiceMsg = crypto.int32ToHexString(choice);
        var N = mixServEncKeys.length; // the number of mix servers
        var ciphertexts = new Array(N+1); // array with the chain of ciphertexts
        var randomCoins = new Array(N); // array with the used random coins

        // generate a random receipt id
        var receiptID = crypto.nonce().slice(0,16);

        // create the inner-most message (receiptID,choice)
        ciphertexts[N] = pair(electionID, pair(receiptID, choiceMsg));

        // encrypt the message for the chain of mix servers
        for (var i=N-1; i>=0; --i) {
            var r = crypto.pke_generateEncryprionCoins();
        	ciphertexts[i] = enc(mixServEncKeys[i], pair(electionID, ciphertexts[i+1]), r);
            randomCoins[i] = r;
        }

        ballot = ciphertexts[0];

        return { electionID: electionID, 
                 ballot: ballot, 
                 choice: choice, 
                 receiptID: receiptID, 
                 ciphertexts: ciphertexts,
                 randomCoins: randomCoins};
    }


    ///
    // Method validateReceipt
    //
    // Returns true if the given receipt is valid 
    //
    function validateReceipt (receipt) {
        // check if there is no mismatch of election ids
        if (electionID !== receipt.electionID) return false;
        // check the signature
        message = pair(TAG_ACCEPTED, pair(electionID, receipt.ballot));
        return crypto.verifsig(colServVerifKey, message, receipt.signature); 
    }

    return {createBallot: createBallot, validateReceipt: validateReceipt};
}

//////////////////////////////////////////////////////////////////////////////////////////////
return exports;
}();

if (typeof(module)!=='undefined' && module.exports) {
    module.exports = voterClient;
}

